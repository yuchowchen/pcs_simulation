// PCS Simulator Main Entry Point - GOOSE Publisher
// 
// Flow:
// 1. Initialize PCS data from pcs.csv
// 2. Load PCS type mappings from JSON
// 3. Initialize GOOSE frames for each PCS
// 4. Update frames with real-time data
// 5. Send frames to both LANs

use anyhow::Result;
use crossbeam_channel::{bounded};
use pcs_simulator::goose::buffer_pool::BufferPool;
use pcs_simulator::goose::packet_processor::PacketData;
use pcs_simulator::pms::types::PmsConfig;
use pcs_simulator::network::setup_network_channels;
use pcs_simulator::pcs::nameplate::load_nameplates_from_csv;
use pcs_simulator::pcs::{load_pcs_type_mappings};
use pcs_simulator::pcs::publisher::initialize_goose_frames_for_pcs;
use log::{error, info, warn};
use pnet_datalink::DataLinkSender;
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant, SystemTime};

fn main() {
    if let Err(e) = run() {
        error!("Application error: {:?}", e);
        std::process::exit(1);
    }
}

fn run() -> Result<()> {
    info!("========================================");
    info!("PCS Simulator Starting - GOOSE Publisher");
    info!("========================================");

    // Step 1: Load configuration
    let config_paras = match pcs_simulator::os::start::start() {
        Ok(params) => {
            println!("✅ Application startup configuration successful");
            params
        }
        Err(e) => {
            eprintln!("ERROR: Failed to initialize application: {}", e);
            panic!("Cannot continue");
        }
    };


     // Determine number of CPU cores for worker threads
    let num_workers = num_cpus::get();
    info!(
        "System has {} CPU cores, spawning {} worker threads",
        num_workers,
        num_workers - 1
    );

    // Setup network channels
    let mut network_channels = match setup_network_channels(&config_paras.1) {
        Ok(channels) => {
            println!("✅ Network channels setup successfully");
            channels
        }
        Err(e) => {
            eprintln!("ERROR: Failed to setup network channels: {}", e);
            panic!("Cannot continue without network channels");
        }
    };

    // Create channels for communication
    let (packet_tx, packet_rx) = bounded(16384); // receive pcs packets - increased for high traffic
    let (goose_tx, goose_rx) = bounded(10); // goose packet channel for PLC sender

 

    let config_path = &config_paras.0;
    let nameplate_file = format!("{}pcs.csv", config_path);
    let mapping_file = format!("{}PCS_publisher_alldata_mapping.json", config_path);

    let pcs_config = load_nameplates_from_csv(&nameplate_file)?;
    let pcs_type_config = load_pcs_type_mappings(&mapping_file);
    // unwrap pcs_type_config
    let pcs_type_config = match pcs_type_config {
        Ok(config) => config,
        Err(e) => {
            error!("Failed to load PCS type mappings: {:?}", e);
            return Err(e);
        }
    };


    let pms_configs= PmsConfig::load_pms_configs(&pcs_config);
    let (pms_command_appid_list, pms_command_pcs_mapping) = match pms {
        Ok(pms_command_appid_list,pms_command_pcs_mapping) => {
            info!("✅ Loaded PMS configuration successfully");
            (pms_command_appid_list, pms_command_pcs_mapping)
        }
        Err(e) => {
            error!("Failed to load PMS configuration: {:?}", e);
            return Err(e);
        }
    };
    info!("✅ Loaded PMS configuration successfully");

    // for test 
    // log::info!("Loaded {:? } PCS nameplates", pcs_config);
    // log::info!("Loaded {:? } PCS type mappings", pcs_type_config);

    //iterator pcs_config to initialize goose frames
   let mut pcs_frames = initialize_goose_frames_for_pcs(&pcs_config, &pcs_type_config);
    info!("✅ Initialized GOOSE frames for all PCS devices");
    info!("----------------------------------------");
    info!("pcs frmaes are : {:?}", pcs_frames);

  // Spawn worker threads
    let worker_handles = spawn_worker_threads(
        packet_rx,
        pms_config,
    pms_subscribers,
        num_workers,
    );






    Ok(())
  
}




