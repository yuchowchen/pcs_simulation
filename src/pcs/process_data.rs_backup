// defined real time data structure read from pcs goose publisher
// function to calculate the total active power and reactive power of all pcs units.
// function to update the process data structure when new goose message received.
use anyhow::Result;
use crate::goose::types::{EthernetHeader, IECGoosePdu};
use crate::pcs::PublisherPcsData;
use dashmap::DashMap;
use log::{error, info};

/// Immutable index data that never changes after initialization
/// This is thread-safe to share across multiple threads without synchronization
#[derive(Debug, Clone)]
pub struct AppIdIndex {
    /// Index mapping goose_appid -> (logical_id, pcs_type) for fast GOOSE packet processing in LAN1
    pub appid_to_logical_lan1: std::collections::HashMap<u16, (u16, String)>,
    /// Index mapping goose_appid -> (logical_id, pcs_type) for fast GOOSE packet processing in LAN2
    pub appid_to_logical_lan2: std::collections::HashMap<u16, (u16, String)>,
}

impl Default for AppIdIndex {
    fn default() -> Self {
        Self {
            appid_to_logical_lan1: std::collections::HashMap::new(),
            appid_to_logical_lan2: std::collections::HashMap::new(),
        }
    }
}

/// Mutable PCS data that gets updated during GOOSE packet processing
/// This requires synchronization when accessed from multiple threads
#[derive(Debug, Default)]
pub struct MutablePcsData {
    /// Primary storage indexed by logical_id for fast logical_id lookups
    pub pcs_all_lan1: DashMap<u16, PublisherPcsData>,
    pub pcs_all_lan2: DashMap<u16, PublisherPcsData>,
}

/// Main ProcessData structure separating immutable index from mutable data
#[derive(Debug, Default)]
pub struct ProcessData {
    /// Immutable APPID index - safe to share across threads without locks
    pub appid_index: AppIdIndex,
    /// Mutable PCS data - requires synchronization for thread safety
    pub mutable_data: MutablePcsData,
}

impl ProcessData {
    /// Try to build a `PCSData` from a decoded IECGoosePdu and update the
    /// process data with the new values. Returns true if update occurred.
    /// lan_id: 1 for LAN1, 2 for LAN2 - specifies which LAN the GOOSE packet came from
    pub fn update_from_goose_pdu(&mut self, header: &EthernetHeader, pdu: &IECGoosePdu, lan_id: u16) -> bool {
        /// convert two u8 to u16
        fn u8_to_u16(bytes: &[u8]) -> u16 {
            ((bytes[0] as u16) << 8) | (bytes[1] as u16)
        }
        let appid = u8_to_u16(&header.APPID); // use the APPID from the header as pcs_id

        info!("Received GOOSE packet with APPID: {} from LAN{}, updating PCS data", appid, lan_id);

        // Search only in the specified LAN based on lan_id
        match lan_id {
            1 => {
                // Search in LAN1 only
                if let Some(&(logical_id, ref _pcs_type)) = self.appid_index.appid_to_logical_lan1.get(&appid) {
                    if let Some(mut pcs) = self.mutable_data.pcs_all_lan1.get_mut(&logical_id) {
                        pcs.update_from_goose(pdu, lan_id);
                        info!("Updated PCS data for APPID {} (logical_id: {}) in LAN1", appid, logical_id);
                        return true;
                    }
                }
                log::warn!("No PCS found with APPID: {} in LAN{}", appid, lan_id);
            }
            2 => {
                // Search in LAN2 only
                if let Some(&(logical_id, ref _pcs_type)) = self.appid_index.appid_to_logical_lan2.get(&appid) {
                    if let Some(mut pcs) = self.mutable_data.pcs_all_lan2.get_mut(&logical_id) {
                        pcs.update_from_goose(pdu, lan_id);
                        info!("Updated PCS data for APPID {} (logical_id: {}) in LAN2", appid, logical_id);
                        return true;
                    }
                }
                log::warn!("No PCS found with APPID: {} in LAN{}", appid, lan_id);
            }
            _ => {
                log::warn!("Invalid LAN ID: {}. Expected 1 (LAN1) or 2 (LAN2)", lan_id);
            }
        }

        false
    }

} // end of impl ProcessData

impl MutablePcsData {

    /// Process a command GOOSE frame from the controller and update all PCS units it controls
    /// 
    /// This method handles GOOSE frames that contain commands for multiple PCS units.
    /// It determines which PCS units are controlled by this GOOSE frame and updates
    /// their feedback values based on the commands.
    /// 
    /// # Arguments
    /// * `header` - Ethernet header containing APPID
    /// * `pdu` - GOOSE PDU containing command data for multiple PCS units
    /// * `lan_id` - LAN identifier (1 or 2)
    /// * `number_of_pcs` - Number of PCS units controlled by this GOOSE frame
    /// 
    /// Returns the number of PCS units successfully updated
    pub fn process_command_goose(&mut self, header: &EthernetHeader, pdu: &IECGoosePdu, lan_id: u16, number_of_pcs: usize) -> usize {
        let appid = u16::from_be_bytes([header.APPID[0], header.APPID[1]]);
        
        info!(
            "Processing command GOOSE from LAN{} APPID: 0x{:04X} for {} PCS units",
            lan_id, appid, number_of_pcs
        );
        
        // First, update the GOOSE PDU data for all PCS units that match this APPID
        // Then extract commands for each PCS based on its index
        
        let mut updated_count = 0;
        
        // Get all PCS units that should respond to this APPID
        // For command frames, we need to identify which PCS units are controlled
        // This typically means finding PCS units that have this APPID in their configuration
        
        match lan_id {
            1 => {
                // Find all PCS in LAN1 that use this APPID for receiving commands
                for mut entry in self.pcs_all_lan1.iter_mut() {
                    let pcs = entry.value_mut();
                    // Check if this PCS should respond to this APPID
                    // For subscriber (command) frames, the APPID in the packet matches
                    // the goose_appid in the PCS configuration
                    if pcs.nameplate_appid() == Some(appid) {
                        // Update the PCS with the GOOSE data
                        pcs.update_from_goose(pdu, lan_id);
                        
                        // Determine this PCS's index within the command frame
                        // For now, we'll use a simple sequential approach
                        // In a real system, this would be based on the PCS's position
                        // in the command frame structure
                        let pcs_index = updated_count;
                        
                        if pcs_index < number_of_pcs {
                            // Extract and apply commands for this specific PCS
                            if let Err(e) = pcs.extract_and_apply_commands(pcs_index, number_of_pcs) {
                                log::warn!(
                                    "Failed to extract commands for PCS {} (index {}): {}",
                                    pcs.pcs_id(),
                                    pcs_index,
                                    e
                                );
                            } else {
                                updated_count += 1;
                                log::info!(
                                    "Updated PCS {} feedback from command GOOSE",
                                    pcs.pcs_id()
                                );
                            }
                        }
                    }
                }
            }
            2 => {
                // Find all PCS in LAN2 that use this APPID for receiving commands
                for mut entry in self.pcs_all_lan2.iter_mut() {
                    let pcs = entry.value_mut();
                    if pcs.nameplate_appid() == Some(appid) {
                        pcs.update_from_goose(pdu, lan_id);
                        
                        let pcs_index = updated_count;
                        
                        if pcs_index < number_of_pcs {
                            if let Err(e) = pcs.extract_and_apply_commands(pcs_index, number_of_pcs) {
                                log::warn!(
                                    "Failed to extract commands for PCS {} (index {}): {}",
                                    pcs.pcs_id(),
                                    pcs_index,
                                    e
                                );
                            } else {
                                updated_count += 1;
                                log::info!(
                                    "Updated PCS {} feedback from command GOOSE",
                                    pcs.pcs_id()
                                );
                            }
                        }
                    }
                }
            }
            _ => {
                log::warn!("Invalid LAN ID: {}", lan_id);
            }
        }
        
        if updated_count > 0 {
            info!(
                "Successfully updated {} PCS units from command GOOSE APPID: 0x{:04X}",
                updated_count, appid
            );
        } else {
            log::warn!(
                "No PCS units updated from command GOOSE APPID: 0x{:04X} on LAN{}",
                appid, lan_id
            );
        }
        
        updated_count
    }
    /// Update PCS data from GOOSE PDU using external AppIdIndex reference
    /// This avoids cloning the index and reconstructing ProcessData
    pub fn update_with_index(
        &self,
        appid_index: &AppIdIndex,
        header: &EthernetHeader,
        pdu: &IECGoosePdu,
        lan_id: u16,
    ) -> bool {
        let appid = u16::from_be_bytes(header.APPID);
        
        log::info!("Received GOOSE packet with APPID: {} from LAN{}, updating PCS data", appid, lan_id);
        
        match lan_id {
            1 => {
                if let Some(&(logical_id, ref _pcs_type)) = appid_index.appid_to_logical_lan1.get(&appid) {
                    if let Some(mut pcs) = self.pcs_all_lan1.get_mut(&logical_id) {
                        pcs.update_from_goose(pdu, lan_id);
                        log::info!("Updated PCS data for APPID {} (logical_id: {}) in LAN1", appid, logical_id);
                        return true;
                    } else {
                        log::warn!("PCS with logical_id {} exists in index but not found in LAN{} data", logical_id, lan_id);
                    }
                } else {
                    log::warn!("No PCS found with APPID: {} in LAN{} index", appid, lan_id);
                }
            }
            2 => {
                if let Some(&(logical_id, ref _pcs_type)) = appid_index.appid_to_logical_lan2.get(&appid) {
                    if let Some(mut pcs) = self.pcs_all_lan2.get_mut(&logical_id) {
                        pcs.update_from_goose(pdu, lan_id);
                        log::info!("Updated PCS data for APPID {} (logical_id: {}) in LAN2", appid, logical_id);
                        return true;
                    } else {
                        log::warn!("PCS with logical_id {} exists in index but not found in LAN{} data", logical_id, lan_id);
                    }
                } else {
                    log::warn!("No PCS found with APPID: {} in LAN{} index", appid, lan_id);
                }
            }
            _ => {
                log::warn!("Invalid LAN ID: {}. Expected 1 (LAN1) or 2 (LAN2)", lan_id);
            }
        }
        false
    }
}

impl ProcessData {
    /// Initialize PCS data from nameplate configurations
    /// Both LAN1 and LAN2 will have identical PCS data during initialization
    pub fn init_from_nameplates<P: AsRef<std::path::Path>>(&mut self, path: P) -> Result<()> {
        // Load nameplate configurations directly from CSV
        let mut nameplate_configs = match crate::pcs::nameplate::load_nameplates_from_csv(path) {
            Ok(configs) => configs,
            Err(e) => {
                error!("Failed to load nameplate configurations: {}", e);
                return Err(e);
            }
        };
        
        // Sort nameplate configurations by logical_id for better cache locality and performance
        // This ensures HashMaps are populated in sorted order which can improve iteration performance
        nameplate_configs.sort_by_key(|config| config.logical_id);
        
        info!("Sorted {} nameplate configurations by logical_id for optimized insertion", nameplate_configs.len());
        
        // Clear existing data and indices
        self.mutable_data.pcs_all_lan1.clear();
        self.mutable_data.pcs_all_lan2.clear();
        self.appid_index.appid_to_logical_lan1.clear();
        self.appid_index.appid_to_logical_lan2.clear();
        
        // Build PCS data from nameplate configurations (now in sorted order)
        for config in nameplate_configs {
            // Extract logical_id from nameplate config, skip if None
            let logical_id = match config.logical_id {
                Some(id) => id,
                None => {
                    error!("Skipping nameplate config without logical_id: {:?}", config.device_id);
                    continue;
                }
            };
            
            // Create PublisherPcsData instance
            let mut pcs = PublisherPcsData::new();
            pcs.set_nameplate(config.clone());
            
            // Clone the PCS data for both LANs (identical initialization)
            let pcs_lan1 = pcs.clone();
            let pcs_lan2 = pcs;
            
            // Insert into LAN1 HashMap and build APPID index
            if let Some(appid) = pcs_lan1.nameplate_appid() {
                self.appid_index.appid_to_logical_lan1.insert(appid, (logical_id, config.pcs_type.clone().unwrap_or_default()));
            }
            self.mutable_data.pcs_all_lan1.insert(logical_id, pcs_lan1);
            
            // Insert into LAN2 HashMap and build APPID index (identical to LAN1)
            if let Some(appid) = pcs_lan2.nameplate_appid() {
                self.appid_index.appid_to_logical_lan2.insert(appid, (logical_id, config.pcs_type.clone().unwrap_or_default()));
            }
            self.mutable_data.pcs_all_lan2.insert(logical_id, pcs_lan2);
        }
        
        info!("Initialized {} PCS units in LAN1 from nameplate configuration", self.mutable_data.pcs_all_lan1.len());
        info!("Initialized {} PCS units in LAN2 from nameplate configuration", self.mutable_data.pcs_all_lan2.len());
        info!("Built LAN1 APPID index with {} entries", self.appid_index.appid_to_logical_lan1.len());
        info!("Built LAN2 APPID index with {} entries", self.appid_index.appid_to_logical_lan2.len());
        
        Ok(())
    }

 
    /// Get all PCS data from specified LAN for monitoring/debugging
    /// lan_id: 1 for LAN1, 2 for LAN2
    pub fn get_pcs_data_by_lan(&self, lan_id: u8) -> Vec<PublisherPcsData> {
        match lan_id {
            1 => self.mutable_data.pcs_all_lan1.iter().map(|entry| entry.value().clone()).collect(),
            2 => self.mutable_data.pcs_all_lan2.iter().map(|entry| entry.value().clone()).collect(),
            _ => Vec::new(),
        }
    }

    /// Get count of valid PCS units in specified LAN
    /// lan_id: 1 for LAN1, 2 for LAN2
    pub fn valid_pcs_count_by_lan(&self, lan_id: u8) -> usize {
        match lan_id {
            1 => self.mutable_data.pcs_all_lan1.iter().filter(|entry| entry.value().is_data_valid()).count(),
            2 => self.mutable_data.pcs_all_lan2.iter().filter(|entry| entry.value().is_data_valid()).count(),
            _ => 0,
        }
    }

    /// Get count of valid PCS units from both LANs (returns (lan1_count, lan2_count))
    pub fn valid_pcs_count_both_lans(&self) -> (usize, usize) {
        let lan1_count = self.valid_pcs_count_by_lan(1);
        let lan2_count = self.valid_pcs_count_by_lan(2);
        (lan1_count, lan2_count)
    }

    /// Fast lookup: Get PCS data by logical_id from specified LAN (O(1) operation)
    /// lan_id: 1 for LAN1, 2 for LAN2
    /// Returns a reference guard that dereferences to PublisherPcsData
    pub fn get_pcs_by_logical_id(&self, logical_id: u16, lan_id: u8) -> Option<dashmap::mapref::one::Ref<'_, u16, PublisherPcsData>> {
        match lan_id {
            1 => self.mutable_data.pcs_all_lan1.get(&logical_id),
            2 => self.mutable_data.pcs_all_lan2.get(&logical_id),
            _ => None,
        }
    }

    /// Fast lookup: Get mutable PCS data by logical_id from specified LAN (O(1) operation)
    /// lan_id: 1 for LAN1, 2 for LAN2
    /// Returns a mutable reference guard that dereferences to PublisherPcsData
    pub fn get_pcs_by_logical_id_mut(&mut self, logical_id: u16, lan_id: u8) -> Option<dashmap::mapref::one::RefMut<'_, u16, PublisherPcsData>> {
        match lan_id {
            1 => self.mutable_data.pcs_all_lan1.get_mut(&logical_id),
            2 => self.mutable_data.pcs_all_lan2.get_mut(&logical_id),
            _ => None,
        }
    }

    /// Get PCS data by logical_id from both LANs (returns (lan1_pcs, lan2_pcs))
    pub fn get_pcs_by_logical_id_both_lans(&self, logical_id: u16) -> (Option<dashmap::mapref::one::Ref<'_, u16, PublisherPcsData>>, Option<dashmap::mapref::one::Ref<'_, u16, PublisherPcsData>>) {
        let lan1_pcs = self.mutable_data.pcs_all_lan1.get(&logical_id);
        let lan2_pcs = self.mutable_data.pcs_all_lan2.get(&logical_id);
        (lan1_pcs, lan2_pcs)
    }

    /// Fast lookup: Get PCS data by goose_appid from specified LAN (O(1) operation)
    /// lan_id: 1 for LAN1, 2 for LAN2
    /// Returns a reference guard that dereferences to PublisherPcsData
    pub fn get_pcs_by_appid(&self, appid: u16, lan_id: u8) -> Option<dashmap::mapref::one::Ref<'_, u16, PublisherPcsData>> {
        match lan_id {
            1 => {
                if let Some(&(logical_id, ref _pcs_type)) = self.appid_index.appid_to_logical_lan1.get(&appid) {
                    self.mutable_data.pcs_all_lan1.get(&logical_id)
                } else {
                    None
                }
            }
            2 => {
                if let Some(&(logical_id, ref _pcs_type)) = self.appid_index.appid_to_logical_lan2.get(&appid) {
                    self.mutable_data.pcs_all_lan2.get(&logical_id)
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    /// Fast lookup: Get mutable PCS data by goose_appid from specified LAN (O(1) operation)
    /// lan_id: 1 for LAN1, 2 for LAN2
    /// Returns a mutable reference guard that dereferences to PublisherPcsData
    pub fn get_pcs_by_appid_mut(&mut self, appid: u16, lan_id: u8) -> Option<dashmap::mapref::one::RefMut<'_, u16, PublisherPcsData>> {
        match lan_id {
            1 => {
                if let Some(logical_id) = self.appid_index.appid_to_logical_lan1.get(&appid).map(|&(logical_id, _)| logical_id) {
                    self.mutable_data.pcs_all_lan1.get_mut(&logical_id)
                } else {
                    None
                }
            }
            2 => {
                if let Some(logical_id) = self.appid_index.appid_to_logical_lan2.get(&appid).map(|&(logical_id, _)| logical_id) {
                    self.mutable_data.pcs_all_lan2.get_mut(&logical_id)
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    /// Get PCS data by goose_appid from both LANs (returns (lan1_pcs, lan2_pcs))
    pub fn get_pcs_by_appid_both_lans(&self, appid: u16) -> (Option<dashmap::mapref::one::Ref<'_, u16, PublisherPcsData>>, Option<dashmap::mapref::one::Ref<'_, u16, PublisherPcsData>>) {
        let lan1_pcs = self.get_pcs_by_appid(appid, 1);
        let lan2_pcs = self.get_pcs_by_appid(appid, 2);
        (lan1_pcs, lan2_pcs)
    }

    /// Add a PCS to LAN1 (with automatic index building)
    pub fn add_pcs_to_lan1(&mut self, logical_id: u16, pcs: PublisherPcsData) {
        // Build APPID index if nameplate has APPID
        if let Some(appid) = pcs.nameplate_appid() {
            self.appid_index.appid_to_logical_lan1.insert(appid, (logical_id, pcs.nameplate_pcs_type().unwrap_or_default()));
        }
        self.mutable_data.pcs_all_lan1.insert(logical_id, pcs);
    }

    /// Add a PCS to LAN2 (with automatic index building)
    pub fn add_pcs_to_lan2(&mut self, logical_id: u16, pcs: PublisherPcsData) {
        // Build APPID index if nameplate has APPID
        if let Some(appid) = pcs.nameplate_appid() {
            self.appid_index.appid_to_logical_lan2.insert(appid, (logical_id, pcs.nameplate_pcs_type().unwrap_or_default()));
        }
        self.mutable_data.pcs_all_lan2.insert(logical_id, pcs);
    }

    /// Get statistics about the PCS data structure
    pub fn get_stats(&self) -> (usize, usize, usize, usize) {
        (
            self.mutable_data.pcs_all_lan1.len(),
            self.mutable_data.pcs_all_lan2.len(),
            self.appid_index.appid_to_logical_lan1.len(),
            self.appid_index.appid_to_logical_lan2.len(),
        )
    }

    /// Find all PCS units (logical_id and goose_appid) that belong to a specific feed_line_id
    /// Returns a vector of tuples containing (logical_id, goose_appid, lan_id)
    /// where lan_id is 1 for LAN1 and 2 for LAN2
    pub fn find_pcs_by_feed_line_id(&self, feed_line_id: u16) -> Vec<(u16, Option<u16>, u8)> {
        let mut results = Vec::new();

        // Search in LAN1
        for entry in self.mutable_data.pcs_all_lan1.iter() {
            let (logical_id, pcs) = entry.pair();
            if pcs.nameplate_feed_line_id() == Some(feed_line_id) {
                results.push((*logical_id, pcs.nameplate_appid(), 1));
            }
        }

        // Search in LAN2
        for entry in self.mutable_data.pcs_all_lan2.iter() {
            let (logical_id, pcs) = entry.pair();
            if pcs.nameplate_feed_line_id() == Some(feed_line_id) {
                results.push((*logical_id, pcs.nameplate_appid(), 2));
            }
        }
        // Sort by logical_id for consistent ordering
        results.sort_by_key(|&(logical_id, _, _)| logical_id);
        info!("Found {} PCS units for feed_line_id {}", results.len(), feed_line_id);
        results
    }

    /// Get only the logical IDs for PCS units belonging to a specific feed_line_id
    pub fn get_logical_ids_by_feed_line_id(&self, feed_line_id: u16) -> Vec<u16> {
        self.find_pcs_by_feed_line_id(feed_line_id)
            .into_iter()
            .map(|(logical_id, _, _)| logical_id)
            .collect()
    }

    /// Get only the GOOSE APPIDs for PCS units belonging to a specific feed_line_id
    /// Filters out None values - returns only PCS units that have a configured GOOSE APPID
    pub fn get_appids_by_feed_line_id(&self, feed_line_id: u16) -> Vec<u16> {
        self.find_pcs_by_feed_line_id(feed_line_id)
            .into_iter()
            .filter_map(|(_, appid, _)| appid)
            .collect()
    }

    /// Get PCS units by feed_line_id separated by LAN
    /// Returns (lan1_pcs, lan2_pcs) where each contains (logical_id, goose_appid)
    pub fn get_pcs_by_feed_line_id_per_lan(&self, feed_line_id: u16) -> (Vec<(u16, Option<u16>)>, Vec<(u16, Option<u16>)>) {
        let all_pcs = self.find_pcs_by_feed_line_id(feed_line_id);
        
        let mut lan1_pcs = Vec::new();
        let mut lan2_pcs = Vec::new();
        
        for (logical_id, appid, lan_id) in all_pcs {
            match lan_id {
                1 => lan1_pcs.push((logical_id, appid)),
                2 => lan2_pcs.push((logical_id, appid)),
                _ => {} // Should not happen
            }
        }
        
        (lan1_pcs, lan2_pcs)
    }

    /// Check if any PCS units exist for a given feed_line_id
    pub fn has_pcs_for_feed_line_id(&self, feed_line_id: u16) -> bool {
        // Check LAN1
        for entry in self.mutable_data.pcs_all_lan1.iter() {
            if entry.value().nameplate_feed_line_id() == Some(feed_line_id) {
                return true;
            }
        }
        
        // Check LAN2
        for entry in self.mutable_data.pcs_all_lan2.iter() {
            if entry.value().nameplate_feed_line_id() == Some(feed_line_id) {
                return true;
            }
        }
        
        false
    }

    /// Get all unique feed_line_ids that are currently configured
    pub fn get_all_feed_line_ids(&self) -> Vec<u16> {
        let mut feed_line_ids = std::collections::HashSet::new();
        
        // Collect from LAN1
        for entry in self.mutable_data.pcs_all_lan1.iter() {
            if let Some(feed_line_id) = entry.value().nameplate_feed_line_id() {
                feed_line_ids.insert(feed_line_id);
            }
        }
        
        // Collect from LAN2
        for entry in self.mutable_data.pcs_all_lan2.iter() {
            if let Some(feed_line_id) = entry.value().nameplate_feed_line_id() {
                feed_line_ids.insert(feed_line_id);
            }
        }
        
        let mut result: Vec<u16> = feed_line_ids.into_iter().collect();
        result.sort();
        result
    }

    /// Get a reference to the immutable APPID index
    /// This is safe to share across threads without synchronization
    pub fn get_appid_index(&self) -> &AppIdIndex {
        &self.appid_index
    }

    /// Get a reference to the mutable PCS data
    /// Requires synchronization when accessed from multiple threads
    pub fn get_mutable_data(&self) -> &MutablePcsData {
        &self.mutable_data
    }

    /// Get a mutable reference to the mutable PCS data
    /// Requires synchronization when accessed from multiple threads
    pub fn get_mutable_data_mut(&mut self) -> &mut MutablePcsData {
        &mut self.mutable_data
    }

    /// Split into components for multi-threaded access
    /// Returns (immutable_index, mutable_data) where:
    /// - immutable_index can be cloned and shared safely across threads
    /// - mutable_data should be wrapped in Arc<Mutex<T>> for thread safety
    pub fn into_components(self) -> (AppIdIndex, MutablePcsData) {
        (self.appid_index, self.mutable_data)
    }

    /// Reconstruct ProcessData from components
    pub fn from_components(appid_index: AppIdIndex, mutable_data: MutablePcsData) -> Self {
        Self {
            appid_index,
            mutable_data,
        }
    }

    /// Perform periodic validity check on all PCS data
    /// This should be called regularly (e.g., every 500ms) to ensure data validity
    /// Returns summary of validity changes: (lan1_newly_invalid_count, lan2_newly_invalid_count)
    pub fn periodic_validity_check(&self) -> (usize, usize) {
        let ((lan1_invalid, lan1_valid), (lan2_invalid, lan2_valid)) = self.mutable_data.check_validity_both_lans();
        
        // Log summary of validity changes
        let lan1_invalid_count = lan1_invalid.len();
        let lan2_invalid_count = lan2_invalid.len();
        let lan1_valid_count = lan1_valid.len();
        let lan2_valid_count = lan2_valid.len();
        
        if lan1_invalid_count > 0 || lan2_invalid_count > 0 || lan1_valid_count > 0 || lan2_valid_count > 0 {
            log::warn!("Periodic validity check: LAN1 ({} invalid, {} valid), LAN2 ({} invalid, {} valid)", 
                      lan1_invalid_count, lan1_valid_count, lan2_invalid_count, lan2_valid_count);
            
            // Get current validity statistics
            let ((lan1_valid_stat, _lan1_invalid_stat, lan1_total), (lan2_valid_stat, _lan2_invalid_stat, lan2_total)) = 
                self.mutable_data.get_validity_stats_both_lans();
                
            log::info!("Current validity status - LAN1: {}/{} valid, LAN2: {}/{} valid", 
                      lan1_valid_stat, lan1_total, lan2_valid_stat, lan2_total);
        }
        
        (lan1_invalid_count, lan2_invalid_count)
    }

    /// Get current validity statistics for monitoring
    /// Returns ((lan1_valid, lan1_invalid, lan1_total), (lan2_valid, lan2_invalid, lan2_total))
    pub fn get_validity_statistics(&self) -> ((usize, usize, usize), (usize, usize, usize)) {
        self.mutable_data.get_validity_stats_both_lans()
    }

    /// Check if a specific PCS unit has valid data
    /// lan_id: 1 for LAN1, 2 for LAN2
    pub fn is_pcs_data_valid(&self, logical_id: u16, lan_id: u8) -> bool {
        match self.get_pcs_by_logical_id(logical_id, lan_id) {
            Some(pcs) => pcs.is_data_valid(),
            None => false,
        }
    }

    /// Get all invalid PCS units for monitoring/alerting
    /// Returns (lan1_invalid_logical_ids, lan2_invalid_logical_ids)
    pub fn get_all_invalid_pcs(&self) -> (Vec<u16>, Vec<u16>) {
        let lan1_invalid = self.mutable_data.get_invalid_pcs_by_lan(1);
        let lan2_invalid = self.mutable_data.get_invalid_pcs_by_lan(2);
        (lan1_invalid, lan2_invalid)
    }
}

impl AppIdIndex {
    /// Fast lookup: Get logical_id by goose_appid from LAN1
    pub fn get_logical_id_lan1(&self, appid: u16) -> Option<u16> {
        self.appid_to_logical_lan1.get(&appid).map(|&(logical_id, _)| logical_id)
    }

    /// Fast lookup: Get logical_id by goose_appid from LAN2
    pub fn get_logical_id_lan2(&self, appid: u16) -> Option<u16> {
        self.appid_to_logical_lan2.get(&appid).map(|&(logical_id, _)| logical_id)
    }

    /// Fast lookup: Get logical_id by goose_appid from either LAN
    /// Returns (logical_id, lan_id) where lan_id is 1 for LAN1, 2 for LAN2
    pub fn get_logical_id_any_lan(&self, appid: u16) -> Option<(u16, u8)> {
        if let Some(&(logical_id, _)) = self.appid_to_logical_lan1.get(&appid) {
            Some((logical_id, 1))
        } else if let Some(&(logical_id, _)) = self.appid_to_logical_lan2.get(&appid) {
            Some((logical_id, 2))
        } else {
            None
        }
    }
    /// Fast lookup: Get (logical_id, pcs_type) by goose_appid from LAN1
    pub fn get_logical_id_and_type_lan1(&self, appid: u16) -> Option<(u16, String)> {
        self.appid_to_logical_lan1.get(&appid).map(|(id, pcs_type)| (*id, pcs_type.clone()))
    }

    /// Fast lookup: Get (logical_id, pcs_type) by goose_appid from LAN2
    pub fn get_logical_id_and_type_lan2(&self, appid: u16) -> Option<(u16, String)> {
        self.appid_to_logical_lan2.get(&appid).map(|(id, pcs_type)| (*id, pcs_type.clone()))
    }

    /// Fast lookup: Get pcs_type by goose_appid from LAN1
    pub fn get_pcs_type_lan1(&self, appid: u16) -> Option<String> {
        self.appid_to_logical_lan1.get(&appid).map(|(_, pcs_type)| pcs_type.clone())
    }

    /// Fast lookup: Get pcs_type by goose_appid from LAN2
    pub fn get_pcs_type_lan2(&self, appid: u16) -> Option<String> {
        self.appid_to_logical_lan2.get(&appid).map(|(_, pcs_type)| pcs_type.clone())
    }

    /// Fast lookup: Get pcs_type by goose_appid from any LAN
    /// Returns (pcs_type, lan_id) where lan_id is 1 for LAN1, 2 for LAN2
    pub fn get_pcs_type_any_lan(&self, appid: u16) -> Option<(String, u8)> {
        if let Some((_, pcs_type)) = self.appid_to_logical_lan1.get(&appid) {
            Some((pcs_type.clone(), 1))
        } else if let Some((_, pcs_type)) = self.appid_to_logical_lan2.get(&appid) {
            Some((pcs_type.clone(), 2))
        } else {
            None
        }
    }

    /// Fast lookup: Get pcs_type by logical_id from LAN1
    /// This performs a reverse lookup through the appid_to_logical_lan1 HashMap
    pub fn get_type_from_logical_id_lan1(&self, logical_id: u16) -> Option<String> {
        self.appid_to_logical_lan1
            .values()
            .find(|(id, _)| *id == logical_id)
            .map(|(_, pcs_type)| pcs_type.clone())
    }

    /// Fast lookup: Get pcs_type by logical_id from LAN2
    /// This performs a reverse lookup through the appid_to_logical_lan2 HashMap
    pub fn get_type_from_logical_id_lan2(&self, logical_id: u16) -> Option<String> {
        self.appid_to_logical_lan2
            .values()
            .find(|(id, _)| *id == logical_id)
            .map(|(_, pcs_type)| pcs_type.clone())
    }

    /// Fast lookup: Get pcs_type by logical_id from any LAN
    /// Returns (pcs_type, lan_id) where lan_id is 1 for LAN1, 2 for LAN2
    /// This performs a reverse lookup through both LAN HashMaps
    pub fn get_type_from_logical_id(&self, logical_id: u16) -> Option<(String, u8)> {
        // Try LAN1 first
        if let Some(pcs_type) = self.get_type_from_logical_id_lan1(logical_id) {
            return Some((pcs_type, 1));
        }
        
        // Try LAN2
        if let Some(pcs_type) = self.get_type_from_logical_id_lan2(logical_id) {
            return Some((pcs_type, 2));
        }
        
        None
    }

}

impl MutablePcsData {
    /// Update PCS data by logical_id in the specified LAN
    pub fn update_pcs_by_logical_id(&mut self, logical_id: u16, lan_id: u8, pdu: &IECGoosePdu) -> bool {
        let pcs = match lan_id {
            1 => self.pcs_all_lan1.get_mut(&logical_id),
            2 => self.pcs_all_lan2.get_mut(&logical_id),
            _ => return false,
        };

        if let Some(mut pcs) = pcs {
            pcs.update_from_goose(pdu, lan_id as u16);
            true
        } else {
            false
        }
    }

    /// Calculate power totals from specified LAN on-demand
    /// lan_id: 1 for LAN1, 2 for LAN2
    /// Returns (total_active_power, total_reactive_power)
    pub fn recalculate_totals_by_lan(&self, lan_id: u8) -> (f32, f32) {
        use crate::goose::types::IECData;
        
        fn extract_power_values(pcs: &PublisherPcsData) -> Option<(f32, f32)> {
            fn collect_f32(acc: &mut Vec<f32>, data: &IECData) {
                match data {
                    IECData::float32(v) => acc.push(*v),
                    IECData::array(vec) | IECData::structure(vec) => {
                        for item in vec {
                            collect_f32(acc, item);
                            if acc.len() >= 2 {
                                return;
                            }
                        }
                    }
                    _ => {}
                }
            }

            let mut floats = Vec::new();
            for d in pcs.get_alldata() {
                collect_f32(&mut floats, d);
                if floats.len() >= 2 {
                    break;
                }
            }

            if floats.len() >= 2 {
                Some((floats[0], floats[1]))
            } else {
                None
            }
        }

        let mut total_active = 0.0_f32;
        let mut total_reactive = 0.0_f32;

        let pcs_collection = match lan_id {
            1 => &self.pcs_all_lan1,
            2 => &self.pcs_all_lan2,
            _ => return (0.0, 0.0),
        };

        // Sum from specified LAN PCS units
        for entry in pcs_collection.iter() {
            let pcs = entry.value();
            if pcs.is_data_valid() {
                if let Some((active, reactive)) = extract_power_values(pcs) {
                    total_active += active;
                    total_reactive += reactive;
                }
            }
        }

        (total_active, total_reactive)
    }

    /// Calculate power totals from both LANs separately
    /// Returns ((lan1_active, lan1_reactive), (lan2_active, lan2_reactive))
    pub fn recalculate_totals_both_lans(&self) -> ((f32, f32), (f32, f32)) {
        let lan1_totals = self.recalculate_totals_by_lan(1);
        let lan2_totals = self.recalculate_totals_by_lan(2);
        (lan1_totals, lan2_totals)
    }

    /// Perform periodic validity check on all PCS data in the specified LAN
    /// This should be called regularly (e.g., every 500ms) to ensure data validity
    /// Returns a tuple of (newly_invalid_ids, newly_valid_ids) for complete visibility
    pub fn check_validity_by_lan(&self, lan_id: u8) -> (Vec<u16>, Vec<u16>) {
        let mut newly_invalid = Vec::new();
        let mut newly_valid = Vec::new();
        let mut currently_invalid = Vec::new();
        
        let pcs_collection = match lan_id {
            1 => &self.pcs_all_lan1,
            2 => &self.pcs_all_lan2,
            _ => return (newly_invalid, newly_valid),
        };

        // Collect all logical IDs first to avoid holding locks during iteration
        let logical_ids: Vec<u16> = pcs_collection.iter().map(|entry| *entry.key()).collect();
        
        // Now process each PCS unit individually
        for logical_id in logical_ids {
            if let Some(mut pcs) = pcs_collection.get_mut(&logical_id) {
                let was_valid = pcs.check_and_update_validity(lan_id);
                let is_valid_now = pcs.is_data_valid();
                
                // Track validity transitions
                if was_valid && !is_valid_now {
                    newly_invalid.push(logical_id);
                    let appid = pcs.nameplate_appid().unwrap_or(0);
                    log::warn!(
                        "VALIDITY CHANGE: LAN{} PCS logical_id={} (APPID: {:04X}) became INVALID due to timeout",
                        lan_id, logical_id, appid
                    );
                } else if !was_valid && is_valid_now {
                    newly_valid.push(logical_id);
                    let appid = pcs.nameplate_appid().unwrap_or(0);
                    log::info!(
                        "VALIDITY CHANGE: LAN{} PCS logical_id={} (APPID: {:04X}) became VALID (recovered from GOOSE)",
                        lan_id, logical_id, appid
                    );
                }
                
                // Track all currently invalid PCS units (not just transitions)
                if !is_valid_now {
                    currently_invalid.push(logical_id);
                }
            }
        }
        
        if !newly_invalid.is_empty() {
            log::warn!(
                "Periodic validity check for LAN{}: {} PCS units became invalid: {:?}",
                lan_id, newly_invalid.len(), newly_invalid
            );
        }
        if !newly_valid.is_empty() {
            log::info!(
                "Periodic validity check for LAN{}: {} PCS units became valid: {:?}",
                lan_id, newly_valid.len(), newly_valid
            );
        }
        
        // Log summary of all currently invalid PCS units (including those that remain invalid)
        if !currently_invalid.is_empty() {
            log::warn!(
                "Validity status summary for LAN{}: {} PCS units currently INVALID (being sent as is_valid=0 via UDP): {:?}",
                lan_id, currently_invalid.len(), currently_invalid
            );
        }
        
        (newly_invalid, newly_valid)
    }

    /// Perform periodic validity check on all PCS data in both LANs
    /// Returns ((lan1_newly_invalid, lan1_newly_valid), (lan2_newly_invalid, lan2_newly_valid))
    pub fn check_validity_both_lans(&self) -> ((Vec<u16>, Vec<u16>), (Vec<u16>, Vec<u16>)) {
        let lan1_results = self.check_validity_by_lan(1);
        let lan2_results = self.check_validity_by_lan(2);
        (lan1_results, lan2_results)
    }

    /// Get count of valid and invalid PCS units in specified LAN
    /// Returns (valid_count, invalid_count, total_count)
    pub fn get_validity_stats_by_lan(&self, lan_id: u8) -> (usize, usize, usize) {
        let pcs_collection = match lan_id {
            1 => &self.pcs_all_lan1,
            2 => &self.pcs_all_lan2,
            _ => return (0, 0, 0),
        };

        let total = pcs_collection.len();
        let valid = pcs_collection.iter().filter(|entry| entry.value().is_data_valid()).count();
        let invalid = total - valid;
        
        (valid, invalid, total)
    }

    /// Get validity statistics for both LANs
    /// Returns ((lan1_valid, lan1_invalid, lan1_total), (lan2_valid, lan2_invalid, lan2_total))
    pub fn get_validity_stats_both_lans(&self) -> ((usize, usize, usize), (usize, usize, usize)) {
        let lan1_stats = self.get_validity_stats_by_lan(1);
        let lan2_stats = self.get_validity_stats_by_lan(2);
        (lan1_stats, lan2_stats)
    }

    /// Get list of all invalid PCS logical_ids in specified LAN
    pub fn get_invalid_pcs_by_lan(&self, lan_id: u8) -> Vec<u16> {
        let pcs_collection = match lan_id {
            1 => &self.pcs_all_lan1,
            2 => &self.pcs_all_lan2,
            _ => return Vec::new(),
        };

        pcs_collection
            .iter()
            .filter_map(|entry| {
                let (logical_id, pcs) = entry.pair();
                if !pcs.is_data_valid() {
                    Some(*logical_id)
                } else {
                    None
                }
            })
            .collect()
    }
}
